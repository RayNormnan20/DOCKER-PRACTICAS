--- Correr app de sprint 
$ ./mvnw spring-boot:run
--- Hacemos un build
./mvnw clean package -DskipTests

--- solo por partes, ósea por el nombre de la app
--- se crea la imagen
docker-compose build java_app

---  debe descargar todas las imágenes de Docker compose
$ docker-compose up

--- Pare eliminar todos los contenedores levantados
$ docker-compose down


ACA HACEMOS PETICIONES A NUESTRA API DESPLEGADA EN DOCKER CONECTADA A OTRO
CONTENEDOR EN ESTE CASO CON POSTGRESQL 


# Especifica la versión del formato de Docker Compose que se está utilizando.
version: '3.9'

services:
  # Define el primer servicio, que es la aplicación Java.
  java_app:
    # Asigna un nombre al contenedor para la aplicación Java.
    container_name: java_app
    # Indica la imagen Docker que se utilizará para este servicio.
    image: pee-java-app:1.0.0
    # Especifica que Docker debe construir la imagen usando el Dockerfile en el directorio actual.
    build: .
    # Mapea el puerto 8080 del contenedor al puerto 8080 del host.
    ports:
      - 8080:8080
    # Define las variables de entorno necesarias para la aplicación Java.
    environment:
      - DATABASE_URL=jdbc:postgresql://java_db:5432/postgres
      - DATABASE_USERNAME=postgres
      - DATABASE_PASSWORD=postgres
    # Establece que este servicio depende del servicio java_db, asegurando que se inicie primero.
    depends_on:
      - java_db
  
  # Define el segundo servicio, que es la base de datos PostgreSQL.
  java_db:
    # Asigna un nombre al contenedor para la base de datos.
    container_name: java_db
    # Indica la imagen Docker que se utilizará para la base de datos.
    image: postgres:12
    # Mapea el puerto 5432 del contenedor al puerto 5432 del host.
    ports:
      - 5432:5432
    # Define las variables de entorno necesarias para configurar la base de datos PostgreSQL.
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
